<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Echoes of Indigo - Blue Anime Platformer</title>
    <style>
        body {
            margin: 0;
            background: #02050a;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }
        canvas {
            display: block;
            /* A subtle vignette effect */
            box-shadow: inset 0 0 100px rgba(0,0,0,0.8);
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #88ccee;
            pointer-events: none;
            text-shadow: 0 0 10px #0088ff;
            font-weight: bold;
        }
        #start-screen {
            position: absolute;
            inset: 0;
            background: rgba(2, 5, 10, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #aaddff;
            z-index: 100;
            transition: opacity 0.5s;
        }
        h1 { letter-spacing: 10px; font-weight: 100; text-shadow: 0 0 20px #0066ff; margin-bottom: 10px; }
        button {
            padding: 15px 30px;
            background: rgba(0, 68, 136, 0.3);
            border: 2px solid #4488aa;
            color: #aaddff;
            cursor: pointer;
            font-family: inherit;
            font-size: 16px;
            margin-top: 30px;
            transition: all 0.2s;
        }
        button:hover { background: rgba(0, 100, 200, 0.5); box-shadow: 0 0 20px #0088ff; }
    </style>
</head>
<body>

    <audio id="bgMusic" loop>
        <source src="fable.mp3" type="audio/mpeg">
    </audio>

    <div id="ui-layer">
        <div>SPIRIT DASH: <span id="dash-indicator">READY</span></div>
        <div style="font-size: 12px; margin-top: 10px; opacity: 0.7;">ARROWS: Move | Z/Space: Jump | X/K: Dash</div>
    </div>

    <div id="start-screen">
        <h1>ECHOES OF INDIGO</h1>
        <p style="font-size: 14px; color: #6699bb;">An atmospheric journey inspired by Antent & Celeste.</p>
        
        <canvas id="previewCanvas" width="100" height="100" style="margin: 20px; box-shadow: none;"></canvas>

        <button onclick="startGame()">AWAKEN</button>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
// --- SETUP & CONSTANTS ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const audio = document.getElementById('bgMusic');
const uiDash = document.getElementById('dash-indicator');

let width, height;
let gameActive = false;
let cameraX = 0;

// Physics tuneables - Tweak these for different "feel"
const PHYS = {
    GRAVITY: 0.6,
    FRICTION: 0.85,
    ACCEL: 1.2,
    MAX_SPEED: 7,
    JUMP_FORCE: -11,
    DASH_SPEED: 18,
    DASH_FRAMES: 8,
    TERMINAL_VELOCITY: 12
};

// Colors
const C = {
    bg: '#02050a',
    ruinDark: '#0a152a',
    ruinLight: '#1a3a5a',
    glowReady: '#00ffff', // Cyan for dash ready
    glowUsed: '#4466aa',  // Dim blue for dash used
    eyes: '#eef'
};


// --- GAME OBJECTS ---

const player = {
    x: 100, y: 500, w: 20, h: 30, // Hitbox size
    vx: 0, vy: 0,
    grounded: false,
    facingRight: true,
    
    // Dash mechanics
    canDash: true,
    isDashing: false,
    dashTimer: 0,
    dashDir: {x:0, y:0},

    // Art mechanics
    trail: [], // For the flowing hair/scarf effect
    animFrame: 0
};

// The world map - add more platforms here to explore further
const platforms = [
    // Ground floor
    {x: -200, y: 600, w: 2000, h: 200}, 
    
    // First climb
    {x: 300, y: 500, w: 120, h: 30},
    {x: 500, y: 400, w: 120, h: 30},
    {x: 200, y: 350, w: 80, h: 30},
    
    // The ruin walls
    {x: 700, y: 300, w: 40, h: 350}, // Tall wall
    {x: 650, y: 350, w: 50, h: 20},  // Ledge

    // Higher platforms
    {x: 850, y: 250, w: 150, h: 20},
    {x: 1100, y: 200, w: 100, h: 20},
    {x: 1300, y: 150, w: 200, h: 20},
];

const rain = [];
for(let i=0; i<150; i++) {
    rain.push({
        x: Math.random() * 2000,
        y: Math.random() * 800,
        speed: Math.random() * 10 + 15,
        len: Math.random() * 20 + 10
    });
}

const keys = {};

// --- CORE FUNCTIONS ---

function init() {
    resize();
    window.addEventListener('resize', resize);
    // Draw character preview on start screen
    drawCharacterPreview(); 
}

function resize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
}

function startGame() {
    document.getElementById('start-screen').style.opacity = '0';
    setTimeout(() => { document.getElementById('start-screen').style.display = 'none'; }, 500);
    gameActive = true;
    audio.play().catch(e => console.log("Audio auto-play blocked, waiting for interaction"));
    requestAnimationFrame(gameLoop);
}

window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

// --- THE GAME LOOP ---

function gameLoop() {
    if (!gameActive) return;
    update();
    draw();
    requestAnimationFrame(gameLoop);
}

// --- UPDATE LOGIC (PHYSICS & CONTROLS) ---

function update() {
    player.animFrame++;

    // 1. DASH INPUT & LOGIC
    if ((keys['KeyX'] || keys['KeyK']) && player.canDash && !player.isDashing) {
        startDash();
    }

    if (player.isDashing) {
        performDashPhysics();
    } else {
        performNormalPhysics();
    }

    // 2. COLLISION & MOVEMENT APPLICATION
    player.x += player.vx;
    handleHorizontalCollision();
    player.y += player.vy;
    handleVerticalCollision();

    // 3. WORLD LIMITS
    if(player.y > height + 100) respawn();

    // 4. CAMERA LERPING (Smoothly follow player)
    // Target X is player X minus half screen width.
    let targetCamX = player.x - width / 2;
    // Smoothly move current cameraX towards targetCamX (lerp 0.1)
    cameraX += (targetCamX - cameraX) * 0.1;

    // 5. UPDATE TRAIL ART
    player.trail.push({x: player.x, y: player.y});
    if(player.trail.length > 10) player.trail.shift();

    // 6. UPDATE UI
    uiDash.innerText = player.canDash ? "READY" : "RECHARGING";
    uiDash.style.color = player.canDash ? C.glowReady : C.glowUsed;
}

// --- PHYSICS HELPERS ---

function startDash() {
    player.isDashing = true;
    player.canDash = false;
    player.dashTimer = PHYS.DASH_FRAMES;
    
    let dx = 0, dy = 0;
    if (keys['ArrowLeft']) dx = -1;
    if (keys['ArrowRight']) dx = 1;
    if (keys['ArrowUp']) dy = -1;
    if (keys['ArrowDown']) dy = 1;
    
    // If no direction pressed, dash in facing direction
    if (dx === 0 && dy === 0) dx = player.facingRight ? 1 : -1;
    
    // Normalize diagonal dash
    if (dx !== 0 && dy !== 0) {
        dx *= 0.707; dy *= 0.707;
    }

    player.dashDir = {x: dx, y: dy};
    // Small freeze frame effect feels good
    player.vx = 0; player.vy = 0; 
}

function performDashPhysics() {
    player.vx = player.dashDir.x * PHYS.DASH_SPEED;
    player.vy = player.dashDir.y * PHYS.DASH_SPEED;
    player.dashTimer--;
    if (player.dashTimer <= 0) {
        player.isDashing = false;
        // Cut speed after dash
        player.vx *= 0.5; player.vy *= 0.5;
    }
}

function performNormalPhysics() {
    // Horizontal Movement
    if (keys['ArrowLeft']) { player.vx -= PHYS.ACCEL; player.facingRight = false; }
    if (keys['ArrowRight']) { player.vx += PHYS.ACCEL; player.facingRight = true; }
    player.vx *= PHYS.FRICTION;

    // Gravity
    player.vy += PHYS.GRAVITY;
    if(player.vy > PHYS.TERMINAL_VELOCITY) player.vy = PHYS.TERMINAL_VELOCITY;

    // Jumping
    if ((keys['KeyZ'] || keys['Space']) && player.grounded) {
        player.vy = PHYS.JUMP_FORCE;
        player.grounded = false;
    }
}

// AABB Collision detection
function collide(r1, r2) {
    return r1.x < r2.x + r2.w && r1.x + r1.w > r2.x &&
           r1.y < r2.y + r2.h && r1.y + r1.h > r2.y;
}

function handleHorizontalCollision() {
    for(let p of platforms) {
        if(collide(player, p)) {
            if(player.vx > 0) player.x = p.x - player.w;
            else if(player.vx < 0) player.x = p.x + p.w;
            player.vx = 0;
        }
    }
}

function handleVerticalCollision() {
    player.grounded = false;
    for(let p of platforms) {
        if(collide(player, p)) {
            if(player.vy > 0) { // Landing
                player.y = p.y - player.h;
                player.grounded = true;
                player.canDash = true; // Refill dash
            } else if (player.vy < 0) { // Hitting ceiling
                player.y = p.y + p.h;
            }
            player.vy = 0;
        }
    }
}

function respawn() {
    player.x = 100; player.y = 500; player.vx = 0; player.vy = 0;
    player.canDash = true;
}

// --- DRAWING (THE ART) ---

function draw() {
    ctx.fillStyle = C.bg;
    ctx.fillRect(0, 0, width, height);

    ctx.save();
    // Apply Camera shift
    ctx.translate(-Math.floor(cameraX), 0);

    drawParallaxBg();
    drawRain();
    drawPlatforms();
    drawPlayerAnime(ctx, player.x, player.y, player.facingRight, player.canDash, player.trail);
    
    ctx.restore();
}

// Procedural Environment Art
function drawPlatforms() {
    platforms.forEach(p => {
        // Main block
        ctx.fillStyle = C.ruinDark;
        ctx.fillRect(p.x, p.y, p.w, p.h);
        
        // "Mossy" glowing top edge
        ctx.fillStyle = '#2a5a7a';
        ctx.fillRect(p.x, p.y, p.w, 4);
        
        // Subtle "cracks"
        ctx.strokeStyle = '#1a3a5a';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p.x + 10, p.y); ctx.lineTo(p.x + 20, p.y+10);
        ctx.moveTo(p.x + p.w - 30, p.y); ctx.lineTo(p.x + p.w - 10, p.y+15);
        ctx.stroke();
    });
}

function drawRain() {
    ctx.strokeStyle = 'rgba(100, 150, 255, 0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    rain.forEach(r => {
        // Parallax rain based on camera
        let renderX = (r.x - cameraX * 0.5) % (width + 200);
        if(renderX < 0) renderX += width + 200;

        ctx.moveTo(renderX, r.y);
        ctx.lineTo(renderX - r.speed/2, r.y + r.len);
        r.y += r.speed;
        if(r.y > height) r.y = -50;
    });
    ctx.stroke();
}

function drawParallaxBg() {
    // Distant silhouette ruins
    ctx.fillStyle = '#040812';
    for(let i=0; i<5; i++) {
        let pX = (i*400) + (cameraX * 0.8);
        ctx.beginPath();
        ctx.moveTo(pX, height);
        ctx.lineTo(pX+50, height-200);
        ctx.lineTo(pX+150, height-150);
        ctx.lineTo(pX+300, height);
        ctx.fill();
    }
}

// --- PROCEDURAL ANIME CHARACTER ---
// This function draws the character using shapes instead of images.
function drawPlayerAnime(targetCtx, x, y, facingRight, canDash, trailData) {
    const centerX = x + player.w/2;
    const centerY = y + player.h/2;
    const glowColor = canDash ? C.glowReady : C.glowUsed;
    
    targetCtx.save();

    // 1. Draw the "Hair/Scarf" Trail
    if(trailData && trailData.length > 1) {
        targetCtx.beginPath();
        targetCtx.moveTo(trailData[0].x + player.w/2, trailData[0].y + player.h/2 - 5);
        for(let i=1; i<trailData.length; i++) {
             // Add subtle wave motion to trail
            let wave = Math.sin(player.animFrame * 0.2 + i) * 3;
            targetCtx.lineTo(trailData[i].x + player.w/2 + wave, trailData[i].y + player.h/2 - 5);
        }
        targetCtx.strokeStyle = glowColor;
        targetCtx.lineWidth = 4;
        targetCtx.lineCap = 'round';
        targetCtx.globalAlpha = 0.6;
        targetCtx.stroke();
        targetCtx.globalAlpha = 1.0;
    }

    // Flip context if facing left
    if(!facingRight) {
        targetCtx.translate(centerX, centerY);
        targetCtx.scale(-1, 1);
        targetCtx.translate(-centerX, -centerY);
    }
    
    // 2. The Aura (Glow)
    targetCtx.shadowColor = glowColor;
    targetCtx.shadowBlur = 20;

    // 3. The Body (Silhouette style)
    targetCtx.fillStyle = C.ruinDark;
    // Head
    targetCtx.beginPath();
    targetCtx.arc(centerX, y + 8, 9, 0, Math.PI*2);
    targetCtx.fill();
    // Torso (triangle-ish)
    targetCtx.beginPath();
    targetCtx.moveTo(centerX, y + 15);
    targetCtx.lineTo(centerX - 8, y + player.h - 2);
    targetCtx.lineTo(centerX + 8, y + player.h - 2);
    targetCtx.fill();

    // 4. The Eyes (Anime style glowing slivers)
    targetCtx.shadowBlur = 5;
    targetCtx.fillStyle = C.eyes;
    targetCtx.beginPath();
    //Right eye (viewer perspective)
    targetCtx.ellipse(centerX + 3, y + 8, 3, 1.5, 0, 0, Math.PI*2);
    targetCtx.fill();
    
    targetCtx.restore();
}

// Helper to draw the preview on the start screen
function drawCharacterPreview() {
    const pCtx = document.getElementById('previewCanvas').getContext('2d');
    pCtx.clearRect(0,0,100,100);
    // Fake trail for preview
    let fakeTrail = [];
    for(let i=0; i<5; i++) fakeTrail.push({x: 35-i*2, y: 35});
    drawPlayerAnime(pCtx, 35, 35, true, true, fakeTrail);
}

// Start it up
init();
</script>
</body>
</html>
