<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BALDSTAFF</title>
    <style>
        @font-face {
            font-family: 'Pixelpurl';
            src: url('https://kaffetish.club/trash/shootcraft/fonts/Pixelpurl-0vBPP.ttf');
        }
        body { margin: 0; overflow: hidden; font-family: 'Pixelpurl', monospace; user-select: none; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        /* HUD */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            background: transparent; border: 2px solid rgba(255, 255, 255, 0.8);
            transform: translate(-50%, -50%); border-radius: 50%;
        }
        #crosshair::after {
            content: ''; position: absolute; top: 50%; left: 50%; width: 4px; height: 4px;
            background: white; transform: translate(-50%, -50%); border-radius: 50%;
        }
        
        #hud-bottom { padding: 20px; display: flex; align-items: flex-end; }
        #health-container { width: 200px; height: 25px; background: #333; border: 2px solid #fff; position: relative; }
        #health-bar { width: 100%; height: 100%; background: #42b132; transition: width 0.2s; }
        #health-text { position: absolute; top: 0; left: 0; width: 100%; text-align: center; color: white; line-height: 25px; font-weight: bold; text-shadow: 1px 1px 0 #000; }
        
        #kill-feed { position: absolute; top: 60px; right: 20px; display: flex; flex-direction: column; align-items: flex-end; pointer-events: none; }
        .kill-msg { color: #fff; font-weight: bold; text-shadow: 1px 1px 0 #000; margin-bottom: 5px; font-size: 16px; }
        
        #tab-scoreboard { display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 600px; background: rgba(0,0,0,0.85); border-radius: 10px; padding: 20px; z-index: 20; justify-content: space-around; color: white; }
        .team-col { width: 45%; }
        .team-col h2 { text-align: center; border-bottom: 2px solid white; padding-bottom: 10px; }
        .player-list { list-style: none; padding: 0; }
        .player-list li { padding: 8px; border-bottom: 1px solid rgba(255,255,255,0.2); font-size: 18px; display: flex; justify-content: space-between; }
        .list-header { display: flex; justify-content: space-between; padding: 5px 8px; font-weight: bold; border-bottom: 1px solid white; margin-bottom: 5px; }
        
        #scoreboard { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); display: flex; gap: 20px; font-size: 24px; font-weight: bold; text-shadow: 2px 2px 0 #000; color: white; }
        .score-blue { color: #009cda; }
        .score-red { color: #e71e07; }
        #timer { font-size: 30px; color: #fcd000; }

        #game-over { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 20; flex-direction: column; align-items: center; justify-content: center; color: white; }
        #winner-text { font-size: 48px; font-weight: bold; margin-bottom: 10px; }
        #restart-text { font-size: 24px; color: #ccc; }

        /* Menu / Connection */
        #menu-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7); display: flex; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 10;
        }
        #menu-box {
            background: rgba(30, 30, 30, 0.95); padding: 40px; border: 4px solid #42b132; 
            text-align: center; max-width: 450px; width: 90%;
            box-shadow: 0 0 30px rgba(0,0,0,0.8); color: white;
            image-rendering: pixelated;
        }
        h1 { margin-top: 0; color: #42b132; font-size: 48px; text-shadow: 4px 4px 0 #000; letter-spacing: 2px; margin-bottom: 20px; }
        input { width: 70%; padding: 12px; margin: 10px 0; background: #222; border: 2px solid #555; color: white; font-family: 'Pixelpurl', monospace; font-size: 16px; outline: none; }
        input:focus { border-color: #42b132; }
        button { padding: 12px 24px; background: #42b132; color: white; border: 2px solid #2a7a20; border-bottom-width: 5px; cursor: pointer; font-size: 20px; font-family: 'Pixelpurl', monospace; margin: 5px; transition: transform 0.1s; text-shadow: 2px 2px 0 #000; }
        button:hover { background: #5cd64f; transform: translateY(-2px); }
        button:active { transform: translateY(2px); border-bottom-width: 2px; margin-top: 7px; margin-bottom: 3px; }
        .status { margin-top: 15px; font-size: 14px; color: #aaa; word-break: break-all; }
        
        #controls-hint { position: absolute; top: 10px; left: 10px; color: rgba(255,255,255,0.7); font-size: 12px; }
        
        .copy-btn { margin-left: 10px; padding: 5px 10px; font-size: 14px; background: #555; border-color: #333; }
        .copy-btn:hover { background: #666; }

        /* Server Browser */
        #server-browser { display: none; flex-direction: column; height: 100%; }
        #server-list { flex: 1; overflow-y: auto; border: 2px solid #444; margin: 15px 0; padding: 10px; text-align: left; background: #111; }
        .server-item { display: flex; justify-content: space-between; align-items: center; background: #222; padding: 10px; margin-bottom: 8px; border: 1px solid #444; color: #eee; }
        .server-item:hover { background: #333; border-color: #666; }
        .server-info { display: flex; flex-direction: column; }
        .server-name { font-weight: bold; font-size: 18px; color: #42b132; }
        .server-meta { font-size: 12px; color: #888; }
        .join-btn { padding: 5px 15px; font-size: 14px; background: #009cda; border-color: #007ba8; margin-left: 10px; }
        .join-btn:hover { background: #33b5e5; }
        .host-options { display: flex; align-items: center; justify-content: center; margin: 15px 0; gap: 10px; }
        
        /* Scrollbar for server list */
        #server-list::-webkit-scrollbar { width: 10px; }
        #server-list::-webkit-scrollbar-track { background: #111; }
        #server-list::-webkit-scrollbar-thumb { background: #444; border: 1px solid #111; }
        #server-list::-webkit-scrollbar-thumb:hover { background: #555; }

        #minimap {
            position: absolute; bottom: 20px; left: 20px;
            width: 150px; height: 150px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #fff; border-radius: 4px;
        }
        
        /* Mobile Controls */
        #mobile-controls { display: none; position: absolute; bottom: 20px; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        #joystick-zone { position: absolute; bottom: 40px; left: 40px; width: 120px; height: 120px; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); border-radius: 50%; pointer-events: auto; }
        #joystick-knob { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background: rgba(255,255,255,0.5); border-radius: 50%; transform: translate(-50%, -50%); }
        .mobile-btn { position: absolute; width: 70px; height: 70px; border-radius: 50%; background: rgba(255,255,255,0.3); border: 2px solid rgba(255,255,255,0.5); color: white; font-weight: bold; pointer-events: auto; display: flex; align-items: center; justify-content: center; user-select: none; }
        .mobile-btn:active { background: rgba(255,255,255,0.5); }
        #mobile-jump { bottom: 40px; right: 40px; }
        #mobile-shoot { bottom: 130px; right: 40px; background: rgba(255,0,0,0.3); border-color: rgba(255,0,0,0.5); }
        #mobile-look-zone { position: absolute; top: 0; right: 0; width: 50%; height: 100%; pointer-events: auto; z-index: -1; }

        #damage-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red; opacity: 0; pointer-events: none; transition: opacity 0.1s;
            z-index: 1;
        }
        #heal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #00ff00; opacity: 0; pointer-events: none; transition: opacity 0.5s;
            z-index: 1;
        }
    </style>
</head>
<body>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div id="damage-overlay"></div>
        <div id="heal-overlay"></div>
        <div id="controls-hint">WASD to Move | SPACE to Jump | CLICK to Shoot</div>
        <div id="scoreboard"><span class="score-blue" id="score-blue">BLUE: 0</span> <div id="timer">WAITING</div> <span class="score-red" id="score-red">RED: 0</span></div>
        <div id="kill-feed"></div>
        <div id="crosshair"></div>
        <div id="tab-scoreboard">
            <div class="team-col">
                <h2 style="color:#009cda">BLUE TEAM</h2>
                <div class="list-header"><span>Name</span> <span>K / D</span></div>
                <ul id="blue-list" class="player-list"></ul>
            </div>
            <div class="team-col">
                <h2 style="color:#e71e07">RED TEAM</h2>
                <div class="list-header"><span>Name</span> <span>K / D</span></div>
                <ul id="red-list" class="player-list"></ul>
            </div>
        </div>
        <div id="hud-bottom">
            <div id="health-container">
                <div id="health-bar"></div>
                <div id="health-text">100 HP</div>
            </div>
        </div>
        <canvas id="minimap" width="150" height="150"></canvas>
    </div>
    
    <!-- Game Over Screen -->
    <div id="game-over">
        <div id="winner-text">BLUE WINS!</div>
        <div id="restart-text">Next match in 3...</div>
    </div>

    <!-- Mobile Controls -->
    <div id="mobile-controls">
        <div id="mobile-look-zone"></div>
        <div id="joystick-zone"><div id="joystick-knob"></div></div>
        <div id="mobile-shoot" class="mobile-btn">FIRE</div>
        <div id="mobile-jump" class="mobile-btn">JUMP</div>
    </div>

    <!-- Menu Overlay -->
    <div id="menu-overlay">
        <div id="menu-box">
            <div id="main-menu">
                <img src="https://kaffetish.club/trash/shootcraft/baldstaff.png" alt="Baldstaff" style="max-width: 100%; margin-bottom: 20px;">
                <input type="text" id="nickname-input" placeholder="Enter Nickname" maxlength="10">
                <p>Your ID: <span id="my-id">Generating...</span> <button id="copy-btn" class="copy-btn">Copy</button></p>
                <hr style="border-color: #444; margin: 20px 0;">
                <div id="menu-default">
                    <input type="text" id="peer-id-input" placeholder="Enter Opponent ID">
                    <button id="connect-btn">Connect</button>
                    <button id="browse-btn" style="background:#009cda; border-color:#007ba8; margin-top:5px;">Browse Public Servers</button>
                    <p>OR</p>
                    <div class="host-options">
                        <label style="font-size:18px; color:#eee; display:flex; align-items:center; cursor:pointer;">
                            <input type="checkbox" id="public-host-check" style="width:auto; margin:0 10px 0 0; transform: scale(1.5);"> Public Game
                        </label>
                    </div>
                    <button id="play-btn">Play Solo / Host</button>
                </div>
                <div id="server-browser">
                    <h2 style="font-size: 24px; margin-bottom: 10px; color: #009cda;">Public Servers</h2>
                    <div id="server-list">Connecting to directory...</div>
                    <button id="back-btn" style="background:#757575; border-color: #616161;">Back</button>
                </div>
                <div class="status" id="status-msg">Ready to connect.</div>
            </div>
            <div id="pause-menu" style="display:none;">
                <h1>Paused</h1>
                <button id="resume-btn">Resume</button>
                <button id="exit-btn" style="background:#e71e07; border-color:#b01605; margin-top:10px;">Exit Match</button>
            </div>
        </div>
    </div>

    <!-- Import Maps -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "peerjs": "https://esm.sh/peerjs@1.5.2?bundle-deps",
                "mqtt": "https://esm.sh/mqtt@5.3.5"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { Peer } from 'peerjs';
        import mqtt from 'mqtt';

        // --- Configuration ---
        const WORLD_SIZE = 90;
        const PLAYER_HEIGHT = 1.8;
        
        // Physics Constants (Minecraft-like, converted to blocks/sec)
        const GRAVITY = 32.0;           // 0.08 blocks/tick^2
        const JUMP_FORCE = 9.0;         // ~1.25 blocks height
        const FRICTION_GROUND = 0.546;  // 0.6 * 0.91
        const FRICTION_AIR = 0.91;
        const ACCEL_WALK = 6.0;
        const ACCEL_SPRINT = 8.0;
        const ACCEL_SNEAK = 2.0;
        const ACCEL_AIR = 0.8;
        const JUMP_BOOST = 4.0;         // 0.2 blocks/tick * 20

        const MQTT_BROKER = 'wss://broker.hivemq.com:8884/mqtt';
        const MQTT_TOPIC = 'voxel-fps-p2p/lobby';
        
        // --- Globals ---
        let camera, scene, renderer, controls;
        let raycaster;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let canJump = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        
        // Game State
        let health = 100;
        let currentHeight = PLAYER_HEIGHT;
        const obstacles = []; // Array of meshes for collision
        const ladders = []; // Array of ladder objects
        const bullets = []; // Active projectiles
        const grenades = []; // Active grenades
        const particles = []; // Visual particles
        const peers = {}; // Connection objects
        const remotePlayers = {}; // Meshes for remote players
        let myPeerId = null;
        let gameStarted = false;
        let isMobile = /Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        
        // Match Logic
        let myNickname = "Player";
        let myTeam = 'blue'; // 'blue' or 'red'
        let matchActive = false;
        let matchTime = 180; // 3 minutes
        let scores = { blue: 0, red: 0 };
        let rounds = { blue: 0, red: 0 };
        let playerStats = {}; // { peerId: { kills: 0, deaths: 0, nick: "...", team: "..." } }
        let isTabPressed = false;
        let isHost = false;
        let isPublic = false;
        let mqttClient = null;
        let discoveredHosts = new Map(); // ID -> { info, timestamp }
        let lastActivityTime = performance.now();
        let soloStartTime = 0;
        
        let lastGrenadeTime = 0;
        let grenadeChargeStart = 0;
        let isChargingGrenade = false;
        
        let isSliding = false;
        let lastSlideTime = 0;
        let isCrouching = false;
        let isSprinting = false;
        let maxY = 0;
        let lastHealTime = 0;
        let lastJumpTime = 0;
        let lastWTime = 0;
        
        let muzzleLight;
        // Mobile Input State
        let joystick = { x: 0, y: 0, active: false, origin: {x:0, y:0} };
        let touchLook = { active: false, lastX: 0, lastY: 0 };
        
        // Map Generation
        let mapGroup;
        let worldSeed = Math.floor(Math.random() * 2147483647);

        // Audio
        const shootSound = new Audio('https://kaffetish.club/trash/shootcraft/shoot.mp3');
        const hitSound = new Audio('https://kaffetish.club/trash/shootcraft/ah.mp3');
        const runSound = new Audio('https://kaffetish.club/trash/shootcraft/run.mp3');
        runSound.loop = true;
        const boomSound = new Audio('https://kaffetish.club/trash/shootcraft/boom.mp3');
        const ouchSound = new Audio('https://kaffetish.club/trash/shootcraft/ouch.m4a');
        const slideSound = new Audio('https://kaffetish.club/trash/shootcraft/sliding.m4a');
        const healSound = new Audio('https://kaffetish.club/trash/shootcraft/heal.mp3');
        
        // DOM Elements
        const menuOverlay = document.getElementById('menu-overlay');
        const mainMenu = document.getElementById('main-menu');
        const pauseMenu = document.getElementById('pause-menu');
        const resumeBtn = document.getElementById('resume-btn');
        const exitBtn = document.getElementById('exit-btn');
        const playBtn = document.getElementById('play-btn');
        const copyBtn = document.getElementById('copy-btn');
        const connectBtn = document.getElementById('connect-btn');
        const peerInput = document.getElementById('peer-id-input');
        const nicknameInput = document.getElementById('nickname-input');
        const statusMsg = document.getElementById('status-msg');
        const myIdDisplay = document.getElementById('my-id');
        const healthBar = document.getElementById('health-bar');
        const healthText = document.getElementById('health-text');
        const killFeed = document.getElementById('kill-feed');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        const scoreBlueEl = document.getElementById('score-blue');
        const scoreRedEl = document.getElementById('score-red');
        const timerEl = document.getElementById('timer');
        const tabScoreboard = document.getElementById('tab-scoreboard');
        const blueList = document.getElementById('blue-list');
        const redList = document.getElementById('red-list');
        const browseBtn = document.getElementById('browse-btn');
        const backBtn = document.getElementById('back-btn');
        const serverBrowser = document.getElementById('server-browser');
        const menuDefault = document.getElementById('menu-default');
        const serverListEl = document.getElementById('server-list');
        const publicCheck = document.getElementById('public-host-check');

        // --- Initialization ---
        init();
        animate();
        initNetwork();

        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 0, 60);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Spawn Logic
            const spawn = getSpawnPoint();
            camera.position.set(spawn.x, PLAYER_HEIGHT, spawn.z);
            camera.lookAt(0, PLAYER_HEIGHT, 0); // Look at center

            mapGroup = new THREE.Group();
            scene.add(mapGroup);

            // Lights
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.8);
            hemiLight.position.set(0, 20, 0);
            scene.add(hemiLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Controls
            controls = new PointerLockControls(camera, document.body);
            
            controls.addEventListener('lock', () => {
                menuOverlay.style.display = 'none';
                if (isTabPressed) showScoreboard(true); // Ensure scoreboard shows if tab held
            });
            controls.addEventListener('unlock', () => {
                // Pause Menu Logic
                if (gameStarted && !isMobile) {
                    mainMenu.style.display = 'none';
                    pauseMenu.style.display = 'block';
                    menuOverlay.style.display = 'flex';
                    
                    // If Tab caused unlock, hide menu immediately to allow quick resume
                    if (isTabPressed) {
                        isSprinting = false; // Reset sprint on tab out
                        menuOverlay.style.display = 'none';
                    }
                }
                runSound.pause();
            });

            // Click to resume if unlocked by Tab
            document.addEventListener('click', () => {
                if (gameStarted && !isMobile && !controls.isLocked && menuOverlay.style.display === 'none') {
                    controls.lock();
                }
            });

            // World Generation
            generateWorld(worldSeed);

            // Weapon (Visual)
            const gunGeo = new THREE.BoxGeometry(0.1, 0.1, 0.4);
            const gunMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const gun = new THREE.Mesh(gunGeo, gunMat);
            gun.position.set(0.2, -0.2, -0.3);
            
            muzzleLight = new THREE.PointLight(0xffff00, 0, 3);
            muzzleLight.position.set(0, 0, -0.3);
            gun.add(muzzleLight);
            
            camera.add(gun);
            scene.add(camera);

            // Raycaster
            raycaster = new THREE.Raycaster();

            // Event Listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', () => lastActivityTime = performance.now());
            window.addEventListener('resize', onWindowResize);
            
            playBtn.addEventListener('click', (e) => { 
                e.stopPropagation();
                if (nicknameInput.value) myNickname = nicknameInput.value;
                isPublic = publicCheck.checked;
                isHost = true; // Playing solo/waiting implies hosting
                myTeam = 'blue'; // Host is always blue initially
                gameStarted = true; 
                lastActivityTime = performance.now();
                soloStartTime = performance.now();
                if (!isMobile) controls.lock();
                else menuOverlay.style.display = 'none';
                if (isPublic) startAdvertising();
            });
            resumeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                if (!isMobile) controls.lock();
                else menuOverlay.style.display = 'none';
            });
            exitBtn.addEventListener('click', exitMatch);
            copyBtn.addEventListener('click', () => {
                if (myPeerId) {
                    navigator.clipboard.writeText(myPeerId);
                    copyBtn.innerText = "Copied!";
                    setTimeout(() => copyBtn.innerText = "Copy", 2000);
                }
            });
            connectBtn.addEventListener('click', () => {
                if (nicknameInput.value) myNickname = nicknameInput.value;
                const id = peerInput.value;
                if(id) connectToPeer(id);
            });
            
            browseBtn.addEventListener('click', () => {
                menuDefault.style.display = 'none';
                serverBrowser.style.display = 'flex';
                startBrowsing();
            });
            
            backBtn.addEventListener('click', () => {
                serverBrowser.style.display = 'none';
                menuDefault.style.display = 'block';
                stopBrowsing();
            });

            // Mobile Events
            if (isMobile) {
                document.getElementById('mobile-controls').style.display = 'block';
                document.getElementById('controls-hint').style.display = 'none';

                const joyZone = document.getElementById('joystick-zone');
                const joyKnob = document.getElementById('joystick-knob');
                const lookZone = document.getElementById('mobile-look-zone');
                
                joyZone.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    lastActivityTime = performance.now();
                    const touch = e.changedTouches[0];
                    joystick.active = true;
                    joystick.origin = { x: touch.clientX, y: touch.clientY };
                    joystick.id = touch.identifier;
                }, {passive: false});

                joyZone.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!joystick.active) return;
                    const touch = Array.from(e.changedTouches).find(t => t.identifier === joystick.id);
                    if (!touch) return;
                    
                    const dx = touch.clientX - joystick.origin.x;
                    const dy = touch.clientY - joystick.origin.y;
                    const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 40);
                    const angle = Math.atan2(dy, dx);
                    
                    joystick.x = (Math.cos(angle) * dist) / 40;
                    joystick.y = (Math.sin(angle) * dist) / 40;
                    
                    joyKnob.style.transform = `translate(calc(-50% + ${Math.cos(angle)*dist}px), calc(-50% + ${Math.sin(angle)*dist}px))`;
                }, {passive: false});

                const endJoy = (e) => {
                    if (Array.from(e.changedTouches).some(t => t.identifier === joystick.id)) {
                        joystick.active = false;
                        joystick.x = 0; joystick.y = 0;
                        joyKnob.style.transform = `translate(-50%, -50%)`;
                    }
                };
                joyZone.addEventListener('touchend', endJoy);
                joyZone.addEventListener('touchcancel', endJoy);

                lookZone.addEventListener('touchstart', (e) => {
                    touchLook.active = true;
                    touchLook.lastX = e.touches[0].clientX;
                    touchLook.lastY = e.touches[0].clientY;
                    lastActivityTime = performance.now();
                });
                lookZone.addEventListener('touchmove', (e) => {
                    if (!touchLook.active) return;
                    const dx = e.touches[0].clientX - touchLook.lastX;
                    const dy = e.touches[0].clientY - touchLook.lastY;
                    touchLook.lastX = e.touches[0].clientX;
                    touchLook.lastY = e.touches[0].clientY;
                    lastActivityTime = performance.now();
                    
                    camera.rotation.y -= dx * 0.005;
                    camera.rotation.x -= dy * 0.005;
                    camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
                });
                lookZone.addEventListener('touchend', () => touchLook.active = false);

                document.getElementById('mobile-jump').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    lastActivityTime = performance.now();
                    if (canJump) { velocity.y += JUMP_FORCE; canJump = false; }
                });
                document.getElementById('mobile-shoot').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    lastActivityTime = performance.now();
                    onMouseDown({});
                });
            }

            // Network Heartbeat (20 TPS)
            setInterval(() => {
                if (!gameStarted) return;
                broadcast({
                    t: 'm',
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z,
                    ry: camera.rotation.y,
                    tm: myTeam, // Send team for late joiners/verification
                    nick: myNickname
                });
            }, 50);
        }

        // Seeded RNG (Mulberry32)
        function mulberry32(a) {
            return function() {
              var t = a += 0x6D2B79F5;
              t = Math.imul(t ^ t >>> 15, t | 1);
              t ^= t + Math.imul(t ^ t >>> 7, t | 61);
              return ((t ^ t >>> 14) >>> 0) / 4294967296;
            }
        }

        function generateWorld(seed) {
            const rng = mulberry32(seed);
            
            // Clear existing map
            mapGroup.clear();
            obstacles.length = 0;
            ladders.length = 0;

            const loader = new THREE.TextureLoader();
            
            // Textures
            const grassTex = loader.load('https://kaffetish.club/trash/shootcraft/grass.webp');
            grassTex.wrapS = THREE.RepeatWrapping;
            grassTex.wrapT = THREE.RepeatWrapping;
            grassTex.repeat.set(WORLD_SIZE, WORLD_SIZE);
            grassTex.magFilter = THREE.NearestFilter;
            grassTex.colorSpace = THREE.SRGBColorSpace;

            const woodTex = loader.load('https://kaffetish.club/trash/shootcraft/brick.webp');
            woodTex.magFilter = THREE.NearestFilter;
            woodTex.colorSpace = THREE.SRGBColorSpace;

            const ladderTex = loader.load('https://kaffetish.club/trash/shootcraft/ladder.png');
            ladderTex.colorSpace = THREE.SRGBColorSpace;

            // Floor
            const floorGeo = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE);
            const floorMat = new THREE.MeshStandardMaterial({ map: grassTex });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            mapGroup.add(floor);

            // Random Voxels
            const boxGeo = new THREE.BoxGeometry(1, 1, 1);
            const boxMat = new THREE.MeshStandardMaterial({ map: woodTex });

            const createBlock = (x, y, z) => {
                if (Math.abs(x) > WORLD_SIZE/2 - 2 || Math.abs(z) > WORLD_SIZE/2 - 2) return;
                const pos = new THREE.Vector3(x, y, z);
                
                // Check duplicates
                if (obstacles.some(o => o.position.distanceTo(pos) < 0.1)) return;
                
                // Spawn Protection
                if (pos.distanceTo(new THREE.Vector3(0, y, 0)) < 6) return;
                const range = WORLD_SIZE / 2 - 5;
                if (pos.distanceTo(new THREE.Vector3(range, 1, range)) < 8) return;
                if (pos.distanceTo(new THREE.Vector3(-range, 1, range)) < 8) return;
                if (pos.distanceTo(new THREE.Vector3(range, 1, -range)) < 8) return;
                if (pos.distanceTo(new THREE.Vector3(-range, 1, -range)) < 8) return;

                const box = new THREE.Mesh(boxGeo, boxMat);
                box.position.copy(pos);
                mapGroup.add(box);
                obstacles.push(box);
            };

            const ladderGeo = new THREE.PlaneGeometry(0.8, 1);
            const ladderMat = new THREE.MeshStandardMaterial({ 
                map: ladderTex, 
                transparent: true, 
                side: THREE.DoubleSide,
                alphaTest: 0.5
            });

            const createLadder = (x, y, z, ry) => {
                const mesh = new THREE.Mesh(ladderGeo, ladderMat);
                mesh.position.set(x, y, z);
                mesh.rotation.y = ry;
                mapGroup.add(mesh);
                const box = new THREE.Box3().setFromObject(mesh);
                box.expandByScalar(0.2);
                ladders.push({ mesh, box });
            };

            // Structures
            const createWall = (cx, cz) => {
                const isX = rng() > 0.5;
                const len = 4 + Math.floor(rng() * 5); 
                const height = 2 + Math.floor(rng() * 3);
                for (let i = 0; i < len; i++) {
                    for (let h = 0; h < height; h++) {
                        createBlock(isX ? cx + i : cx, 0.5 + h, isX ? cz : cz + i);
                    }
                }
            };

            const createTower = (cx, cz) => {
                const height = 6 + Math.floor(rng() * 4);
                for (let h = 0; h < height; h++) {
                    createBlock(cx, 0.5 + h, cz);
                    createBlock(cx+1, 0.5 + h, cz);
                    createBlock(cx, 0.5 + h, cz+1);
                    createBlock(cx+1, 0.5 + h, cz+1);
                }
                // Platform
                for(let x=-1; x<=2; x++) for(let z=-1; z<=2; z++) {
                    if (x === 0 && z === -1) continue; // Hole for ladder
                    createBlock(cx+x, 0.5 + height, cz+z);
                }
                // Ladders
                for (let h = 0; h < height + 2; h++) {
                    createLadder(cx, 0.5 + h, cz - 0.51, Math.PI);
                }
            };

            const createBuilding = (cx, cz) => {
                const roomCount = 2 + Math.floor(rng() * 2); // 2-3 connected rooms
                let curX = cx, curZ = cz;
                
                for (let r = 0; r < roomCount; r++) {
                    const w = 5 + Math.floor(rng() * 4);
                    const d = 5 + Math.floor(rng() * 4);
                    const h = 3 + Math.floor(rng() * 2);
                    
                    for (let x = 0; x < w; x++) {
                        for (let z = 0; z < d; z++) {
                            // Walls
                            if (x === 0 || x === w-1 || z === 0 || z === d-1) {
                                for (let y = 0; y < h; y++) {
                                    // Doorways
                                    if (y < 2) {
                                        if ((x===0 || x===w-1) && z > 1 && z < d-2) continue;
                                        if ((z===0 || z===d-1) && x > 1 && x < w-2) continue;
                                    }
                                    createBlock(curX + x, 0.5 + y, curZ + z);
                                }
                            }
                            // Roof
                            if ((x+z)%2 === 0) createBlock(curX + x, 0.5 + h, curZ + z);
                        }
                    }
                    // Offset for next room
                    if (rng() > 0.5) curX += w - 1; else curZ += d - 1;
                }
            };

            const createMiniStructure = (cx, cz) => {
                // Minimum 2x2 wall or corner
                createBlock(cx, 0.5, cz); createBlock(cx+1, 0.5, cz);
                createBlock(cx, 1.5, cz); createBlock(cx+1, 1.5, cz);
                if (rng() > 0.5) { // Add corner
                    createBlock(cx, 0.5, cz+1); createBlock(cx, 1.5, cz+1);
                }
            };

            // Generate Map
            for (let i = 0; i < 40; i++) {
                const type = rng();
                const x = Math.round((rng() - 0.5) * (WORLD_SIZE - 20));
                const z = Math.round((rng() - 0.5) * (WORLD_SIZE - 20));
                if (type < 0.4) createWall(x, z);
                else if (type < 0.7) createTower(x, z);
                else createBuilding(x, z);
            }
            
            // Mini Structures (Replacing Scatter)
            for (let i = 0; i < 60; i++) {
                const x = Math.round((rng() - 0.5) * (WORLD_SIZE - 10));
                const z = Math.round((rng() - 0.5) * (WORLD_SIZE - 10));
                createMiniStructure(x, z);
            }

            // Clouds
            const cloudGeo = new THREE.BoxGeometry(6, 2, 4);
            const cloudMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
            for (let i = 0; i < 20; i++) {
                const cloud = new THREE.Mesh(cloudGeo, cloudMat);
                cloud.position.set(
                    (rng() - 0.5) * WORLD_SIZE * 1.5,
                    30 + rng() * 15,
                    (rng() - 0.5) * WORLD_SIZE * 1.5
                );
                mapGroup.add(cloud);
            }
        }

        function getSpawnPoint() {
            const range = WORLD_SIZE / 2 - 5;
            const corners = [
                {x: -range, z: -range}, {x: range, z: -range},
                {x: range, z: range}, {x: -range, z: range}
            ];
            return corners[Math.floor(Math.random() * corners.length)];
        }

        function exitMatch() {
            // Disconnect from all peers
            for (let id in peers) {
                if (peers[id]) {
                    peers[id].close();
                }
            }
            // The 'close' event listeners will handle cleanup.

            if (mqttClient) { mqttClient.end(); mqttClient = null; }
            // Reset local game state
            gameStarted = false;
            health = 100;
            updateHealthUI();
            const spawn = getSpawnPoint();
            camera.position.set(spawn.x, PLAYER_HEIGHT, spawn.z);
            velocity.set(0, 0, 0);

            // Reset UI to initial state
            mainMenu.style.display = 'block';
            pauseMenu.style.display = 'none';
            menuDefault.style.display = 'block';
            serverBrowser.style.display = 'none';
            menuOverlay.style.display = 'flex';
            statusMsg.innerText = "Ready to connect.";
        }
        
        function updateScoreUI() {
            scoreBlueEl.innerText = `BLUE: ${scores.blue} (${rounds.blue})`;
            scoreRedEl.innerText = `RED: ${scores.red} (${rounds.red})`;
        }

        function checkMatchStart() {
            // Host Logic: Start match if 2+ players and not active
            if (isHost && !matchActive && Object.keys(peers).length >= 1) {
                matchActive = true;
                matchTime = 180;
                broadcast({ t: 'sys', k: 'start' });
            }
        }

        function endGame() {
            matchActive = false;
            gameStarted = false;
            document.exitPointerLock();
            document.getElementById('game-over').style.display = 'flex';
            
            let winner = "DRAW";
            if (scores.blue > scores.red) { winner = "BLUE"; rounds.blue++; }
            else if (scores.red > scores.blue) { winner = "RED"; rounds.red++; }
            
            document.getElementById('winner-text').innerText = `${winner} WINS!`;
            updateScoreUI();

            if (isHost) {
                setTimeout(() => {
                    broadcast({ t: 'sys', k: 'restart' });
                    resetMatch();
                }, 3000);
            }
        }

        function resetMatch() {
            scores = { blue: 0, red: 0 };
            for (let id in playerStats) { playerStats[id].kills = 0; playerStats[id].deaths = 0; }
            matchTime = 180;
            matchActive = true;
            gameStarted = true;
            updateScoreUI();
            document.getElementById('game-over').style.display = 'none';
            respawn();
            if (!isMobile) controls.lock();
        }

        // --- Networking ---
        function initNetwork() {
            const shortId = Math.random().toString(36).substring(2, 8);
            const peer = new Peer(shortId, {
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ]
                }
            });
            
            peer.on('open', (id) => {
                myPeerId = id;
                myIdDisplay.innerText = id;
                playerStats[myPeerId] = { 
                    kills: 0, deaths: 0, 
                    nick: myNickname, team: myTeam 
                };
                statusMsg.innerText = "ID Generated. Share it with a friend.";
            });

            peer.on('connection', (conn) => {
                setupConnection(conn);
                statusMsg.innerText = "Incoming connection from " + conn.peer;
            });

            peer.on('error', (err) => {
                console.error(err);
                statusMsg.innerText = "Error: " + err.type;
            });

            window.connectToPeer = (id) => {
                serverBrowser.style.display = 'none';
                menuDefault.style.display = 'block';
                stopBrowsing();

                statusMsg.innerText = "Connecting to " + id + "...";
                const conn = peer.connect(id);
                setupConnection(conn);
            };
        }

        function setupConnection(conn) {
            // Max players check (Host side)
            if (isHost && Object.keys(peers).length >= 9) {
                conn.close();
                return;
            }

            const register = () => {
                if (!peers[conn.peer]) {
                    peers[conn.peer] = conn;
                    soloStartTime = 0;
                    statusMsg.innerText = "Connected to " + conn.peer;
                    
                    // Handshake
                    conn.send({ t: 'hello', nick: myNickname, team: myTeam, seed: worldSeed });
                    
                    if (isHost) {
                        checkMatchStart();
                    }
                }
            };

            if (conn.open) register();
            conn.on('open', register);

            conn.on('data', (data) => {
                register();
                handleData(conn.peer, data);
            });

            conn.on('close', () => {
                removeRemotePlayer(conn.peer);
                delete peers[conn.peer];
                if (isHost && Object.keys(peers).length === 0) soloStartTime = performance.now();
                statusMsg.innerText = "Disconnected from " + conn.peer;
            });
        }

        function handleData(peerId, data) {
            const sourceId = data.id || peerId;

            // Relay Logic (Host Only)
            if (isHost && peerId !== myPeerId && data.t !== 'hello') {
                const relayData = { ...data, id: sourceId };
                if (data.targetId) {
                    if (peers[data.targetId]) peers[data.targetId].send(relayData);
                } else {
                    for (let pid in peers) {
                        if (pid !== peerId) peers[pid].send(relayData);
                    }
                }
            }

            if (data.t === 'hello') {
                // New player joined
                let assignedTeam = data.team;
                
                // Host assigns team to balance
                if (isHost) {
                    let blueCount = (myTeam === 'blue' ? 1 : 0);
                    let redCount = (myTeam === 'red' ? 1 : 0);
                    for(let id in remotePlayers) {
                        if(remotePlayers[id].userData.team === 'blue') blueCount++;
                        else redCount++;
                    }
                    assignedTeam = blueCount <= redCount ? 'blue' : 'red';
                    
                    // Send Welcome Packet with Game State
                    peers[peerId].send({ 
                        t: 'welcome', 
                        team: assignedTeam, 
                        time: matchTime, 
                        active: matchActive,
                        scores: scores,
                        rounds: rounds,
                        stats: playerStats,
                        seed: worldSeed
                    });
                }
                
                createRemotePlayer(peerId, data.nick, assignedTeam);
                
            } else if (data.t === 'welcome') {
                // We just joined, apply state from Host
                myTeam = data.team;
                matchTime = data.time;
                matchActive = data.active;
                scores = data.scores;
                rounds = data.rounds || { blue: 0, red: 0 };
                if (data.stats) playerStats = data.stats;
                
                if (data.seed && data.seed !== worldSeed) {
                    worldSeed = data.seed;
                    generateWorld(worldSeed);
                }

                updateScoreUI();
                gameStarted = true;
                lastActivityTime = performance.now();
                
                menuOverlay.style.display = 'none';
                if (!isMobile) {
                    try { controls.lock(); } catch(e) {}
                }
                
            } else if (data.t === 'm') { // Move
                if (!remotePlayers[sourceId]) {
                    createRemotePlayer(sourceId, data.nick || 'Player', data.tm || 'blue');
                }
                updateRemotePlayer(sourceId, data);
            } else if (data.t === 'h') { // Hit
                if (data.targetId === myPeerId) {
                    takeDamage(data.d, sourceId, data.g);
                }
            } else if (data.t === 's') { // Shoot visual
                visualizeShot(sourceId);
            } else if (data.t === 'g') { // Grenade
                spawnGrenade(new THREE.Vector3(data.x, data.y, data.z), new THREE.Vector3(data.vx, data.vy, data.vz), false);
            } else if (data.t === 'die') { // Player died
                const killerTeam = data.team === 'blue' ? 'red' : 'blue';
                scores[killerTeam]++;
                updateScoreUI();

                // Update Stats
                if (data.victimId && playerStats[data.victimId]) playerStats[data.victimId].deaths++;
                if (data.killerId && playerStats[data.killerId]) playerStats[data.killerId].kills++;
                
                // Sync local stats if we are the victim (redundant but safe)
                if (data.victimId === myPeerId && playerStats[myPeerId]) {
                    playerStats[myPeerId].deaths = Math.max(playerStats[myPeerId].deaths, (playerStats[data.victimId]?.deaths || 0));
                }

                if (isTabPressed) showScoreboard(true); // Refresh if open
                
                const msg = document.createElement('div');
                msg.className = 'kill-msg';
                msg.innerText = data.killer ? `${data.killer} killed ${data.nick}` : `${data.nick} died`;
                killFeed.appendChild(msg);
                setTimeout(() => msg.remove(), 10000);
            } else if (data.t === 'sys') { // System commands
                if (data.k === 'start') { matchActive = true; matchTime = 180; }
                if (data.k === 'tick') { matchTime = data.v; }
                if (data.k === 'end') { endGame(); }
                if (data.k === 'restart') { resetMatch(); }
            }
        }

        function broadcast(data) {
            for (let id in peers) {
                peers[id].send(data);
            }
        }

        // --- MQTT / Public Lobby Logic ---
        function startAdvertising() {
            if (!mqttClient) mqttClient = mqtt.connect(MQTT_BROKER);
            
            mqttClient.on('connect', () => {
                console.log('Connected to Public Lobby');
                statusMsg.innerText = "Public Game Listed.";
                
                // Advertise loop
                const advertise = () => {
                    if (!gameStarted || !isHost) return;
                    const payload = {
                        id: myPeerId,
                        nick: myNickname,
                        players: Object.keys(peers).length + 1,
                        active: matchActive
                    };
                    mqttClient.publish(MQTT_TOPIC, JSON.stringify(payload));
                };
                
                advertise();
                setInterval(advertise, 3000);
            });
        }

        function startBrowsing() {
            serverListEl.innerHTML = '<div style="padding:10px; color:#666;">Connecting to directory...</div>';
            discoveredHosts.clear();
            
            if (mqttClient) mqttClient.end();
            mqttClient = mqtt.connect(MQTT_BROKER);
            
            mqttClient.on('connect', () => {
                serverListEl.innerHTML = '<div style="padding:10px; color:#666;">Searching for games...</div>';
                mqttClient.subscribe(MQTT_TOPIC);
            });

            mqttClient.on('error', (err) => {
                serverListEl.innerHTML = '<div style="padding:10px; color:red;">Connection Error.</div>';
            });

            mqttClient.on('message', (topic, message) => {
                try {
                    const data = JSON.parse(message.toString());
                    if (data.id === myPeerId) return; // Ignore self
                    discoveredHosts.set(data.id, { info: data, ts: Date.now() });
                    updateServerListUI();
                } catch(e) {}
            });
        }

        function stopBrowsing() {
            if (mqttClient) {
                mqttClient.end();
                mqttClient = null;
            }
        }

        function updateServerListUI() {
            const now = Date.now();
            let html = '';
            let count = 0;
            
            discoveredHosts.forEach((val, id) => {
                if (now - val.ts > 5000) { // Remove stale hosts (>5s silence)
                    discoveredHosts.delete(id);
                    return;
                }
                count++;
                html += `<div class="server-item">
                    <div class="server-info"><span class="server-name">${val.info.nick}'s Game</span> <span class="server-meta">Players: ${val.info.players} | Status: ${val.info.active ? 'In Match' : 'Lobby'}</span></div>
                    <button class="join-btn" onclick="window.connectToPeer('${id}')">JOIN</button>
                </div>`;
            });
            
            if (count === 0) serverListEl.innerHTML = '<div style="padding:10px; color:#666;">No public games found.</div>';
            else serverListEl.innerHTML = html;
        }

        // --- Player Logic ---
        function createRemotePlayer(id, nick, team) {
            if (remotePlayers[id]) return;
            
            const group = new THREE.Group();
            group.userData = { team: team, nick: nick };
            
            // Init Stats if not present
            if (!playerStats[id]) {
                playerStats[id] = { kills: 0, deaths: 0, nick: nick, team: team };
            }
            
            // Body
            const bodyGeo = new THREE.BoxGeometry(0.6, 1.8, 0.6);
            const color = team === 'blue' ? 0x009cda : 0xe71e07;
            const bodyMat = new THREE.MeshStandardMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.9 - PLAYER_HEIGHT;
            group.visible = false; // Hide until first update to prevent ghosting at 0,0,0
            group.add(body);

            // Name Tag
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256; canvas.height = 64;
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(0,0,256,64);
            ctx.fillStyle = team === 'blue' ? '#aaaaff' : '#ffaaaa';
            ctx.font = 'bold 30px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(nick || id.substr(0,5), 128, 32);
            
            const sprite = new THREE.Sprite(new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas) }));
            sprite.scale.set(2, 0.5, 1);
            sprite.position.y = 1.2;
            group.add(sprite);

            scene.add(group);
            remotePlayers[id] = group;
        }

        function updateRemotePlayer(id, data) {
            const p = remotePlayers[id];
            if (p) {
                if (!p.userData.targetPos) {
                    p.position.set(data.x, data.y, data.z);
                    p.rotation.y = data.ry;
                    p.userData.targetPos = new THREE.Vector3(data.x, data.y, data.z);
                    p.userData.targetRot = data.ry;
                } else {
                    p.userData.targetPos.set(data.x, data.y, data.z);
                    p.userData.targetRot = data.ry;
                }
                p.visible = true;
            }
        }

        function removeRemotePlayer(id) {
            if (remotePlayers[id]) {
                scene.remove(remotePlayers[id]);
                delete remotePlayers[id];
            }
        }

        function takeDamage(amount, attackerId, isGrenade = false) {
            if (!matchActive) return; // No damage before match starts
            // Friendly Fire Check
            if (!isGrenade && attackerId && remotePlayers[attackerId] && remotePlayers[attackerId].userData.team === myTeam) return;
            
            health -= amount;
            
            const overlay = document.getElementById('damage-overlay');
            overlay.style.opacity = '0.4';
            setTimeout(() => overlay.style.opacity = '0', 200);
            ouchSound.currentTime = 0;
            ouchSound.play().catch(() => {});

            updateHealthUI();
            if (health <= 0) {
                // Broadcast death so everyone updates score
                const killerNick = attackerId ? (remotePlayers[attackerId]?.userData?.nick || "Unknown") : null;
                
                broadcast({ 
                    t: 'die', 
                    victimId: myPeerId,
                    killerId: attackerId,
                    nick: myNickname, 
                    team: myTeam, 
                    killer: killerNick 
                });
                respawn();
            }
        }

        function respawn() {
            health = 100;
            updateHealthUI();
            // Add to enemy score locally
            const enemyTeam = myTeam === 'blue' ? 'red' : 'blue';
            scores[enemyTeam]++;
            updateScoreUI();
            
            const spawn = getSpawnPoint();
            camera.position.set(spawn.x, PLAYER_HEIGHT, spawn.z);
            velocity.set(0, 0, 0);
        }

        function updateHealthUI() {
            healthBar.style.width = health + '%';
            healthText.innerText = health + ' HP';
            if (health < 30) healthBar.style.background = '#e71e07';
            else healthBar.style.background = '#42b132';
        }

        function visualizeShot(peerId) {
            const p = remotePlayers[peerId];
            if (p) {
                const pos = p.position.clone();
                pos.y += 1.5; // Approximate eye level
                
                const dir = new THREE.Vector3(0, 0, -1);
                dir.applyAxisAngle(new THREE.Vector3(0, 1, 0), p.rotation.y);
                
                spawnBullet(pos, dir);
                
                const s = shootSound.cloneNode();
                s.volume = 0.5;
                s.play().catch(() => {});
            }
        }

        function spawnBullet(position, direction, isLocal = false) {
            const bullet = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.2), new THREE.MeshBasicMaterial({ color: 0xffff00 }));
            bullet.position.copy(position);
            bullet.userData = { velocity: direction.multiplyScalar(50), life: 2.0, isLocal: isLocal }; // 50 units/sec, 2 sec life
            scene.add(bullet);
            bullets.push(bullet);
        }

        function createImpact(position) {
            for(let i=0; i<5; i++) {
                const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const mat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(position);
                mesh.position.add(new THREE.Vector3((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5));
                
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5,
                    (Math.random() - 0.5) * 5
                );
                
                scene.add(mesh);
                particles.push({ mesh: mesh, velocity: vel, life: 0.5 });
            }
        }

        function spawnGrenade(pos, vel, isLocal) {
            const geo = new THREE.SphereGeometry(0.2, 8, 8);
            const mat = new THREE.MeshStandardMaterial({ color: 0x228b22 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            mesh.userData = { velocity: vel, isLocal: isLocal };
            scene.add(mesh);
            grenades.push(mesh);
        }

        function explodeGrenade(pos, isLocal) {
            boomSound.currentTime = 0;
            boomSound.play().catch(()=>{});
            
            // Visuals (Simple particles)
            for(let i=0; i<20; i++) {
                const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                const mat = new THREE.MeshBasicMaterial({ color: 0xff4500 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.copy(pos);
                const vel = new THREE.Vector3((Math.random()-0.5)*10, (Math.random()-0.5)*10 + 5, (Math.random()-0.5)*10);
                scene.add(mesh);
                particles.push({ mesh: mesh, velocity: vel, life: 1.0 });
            }

            if (isLocal) {
                const radius = 8;
                const maxDamage = 160;
                
                // Damage Remote Players
                for (let id in remotePlayers) {
                    const dist = remotePlayers[id].position.distanceTo(pos);
                    if (dist < radius) {
                        const dmg = Math.floor(maxDamage * (1 - dist/radius));
                        if (dmg > 0) {
                            const hitData = { t: 'h', d: dmg, targetId: id, g: true };
                            if (peers[id]) peers[id].send(hitData);
                            else broadcast(hitData);
                        }
                    }
                }
                // Damage Self
                const dist = camera.position.distanceTo(pos);
                if (dist < radius) {
                    const dmg = Math.floor(maxDamage * (1 - dist/radius));
                    if (dmg > 0) takeDamage(dmg, null, true);
                }
            }
        }

        // --- Input & Physics ---
        function onKeyDown(event) {
            lastActivityTime = performance.now();
            switch (event.code) {
                case 'Escape':
                    if (gameStarted && !controls.isLocked && !isMobile) {
                        controls.lock();
                    }
                    break;
                case 'Tab':
                    event.preventDefault();
                    isTabPressed = true;
                    showScoreboard(true);
                    break;
                case 'KeyE':
                    if (matchActive && health < 100 && performance.now() - lastHealTime > 12000) {
                        lastHealTime = performance.now();
                        health = Math.min(100, health + 30);
                        updateHealthUI();
                        healSound.currentTime = 0;
                        healSound.play().catch(() => {});
                        const hOverlay = document.getElementById('heal-overlay');
                        hOverlay.style.opacity = '0.3';
                        setTimeout(() => hOverlay.style.opacity = '0', 500);
                    }
                    break;
                case 'ArrowUp': case 'KeyW': 
                    if (!moveForward && !event.repeat) {
                        const now = performance.now();
                        if (now - lastWTime < 300) isSprinting = true;
                        lastWTime = now;
                    }
                    if (event.ctrlKey) isSprinting = true;
                    moveForward = true; 
                    break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'ControlLeft': isSprinting = true; break;
                case 'Space': 
                    if (canJump && performance.now() - lastJumpTime > 250) {
                        velocity.y += JUMP_FORCE; canJump = false; lastJumpTime = performance.now();
                        // Sprint Jump Boost
                        if (isSprinting && moveForward) {
                            // Apply boost in forward direction (local Z is negative forward)
                            // We are working in local velocity space for X/Z
                            velocity.z -= JUMP_BOOST;
                        }
                    }
                    break;
                case 'KeyR':
                    if (matchActive && !isChargingGrenade && performance.now() - lastGrenadeTime > 5000) {
                        isChargingGrenade = true;
                        grenadeChargeStart = performance.now();
                    }
                    break;
                case 'KeyC':
                    camera.fov = 30;
                    camera.updateProjectionMatrix();
                    break;
                case 'KeyF':
                    if (!isSliding && canJump && performance.now() - lastSlideTime > 4000) {
                        isSliding = true;
                        lastSlideTime = performance.now();
                        
                        slideSound.currentTime = 0;
                        slideSound.play().catch(() => {});
                        
                        // Slide Boost
                        let inputZ = Number(moveForward) - Number(moveBackward);
                        let inputX = Number(moveRight) - Number(moveLeft);
                        
                        // Default to forward if no input
                        if (inputZ === 0 && inputX === 0) inputZ = 1;
                        
                        // Normalize
                        const len = Math.sqrt(inputX*inputX + inputZ*inputZ);
                        const dirX = len > 0 ? inputX / len : 0;
                        const dirZ = len > 0 ? inputZ / len : 0;
                        
                        velocity.x = -dirX * 30;
                        velocity.z = -dirZ * 30;
                        currentHeight = PLAYER_HEIGHT * 0.4;
                    }
                    break;
                case 'ShiftLeft': case 'ShiftRight':
                    isCrouching = true;
                    currentHeight = PLAYER_HEIGHT / 2;
                    currentSpeed = MOVEMENT_SPEED / 2;
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'Tab':
                    isTabPressed = false;
                    showScoreboard(false);
                    break;
                case 'ArrowUp': case 'KeyW': 
                    moveForward = false; 
                    isSprinting = false; // Stop sprinting when stopping
                    break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
                case 'ControlLeft': isSprinting = false; break;
                case 'KeyR':
                    if (isChargingGrenade) {
                        const duration = Math.min(performance.now() - grenadeChargeStart, 2000);
                        const force = 15 + (duration / 2000) * 35; 
                        const dir = new THREE.Vector3();
                        camera.getWorldDirection(dir);
                        const vel = dir.multiplyScalar(force);
                        spawnGrenade(camera.position.clone(), vel, true);
                        broadcast({
                            t: 'g', x: camera.position.x, y: camera.position.y, z: camera.position.z,
                            vx: vel.x, vy: vel.y, vz: vel.z
                        });
                        isChargingGrenade = false;
                        lastGrenadeTime = performance.now();
                    }
                    break;
                case 'KeyC':
                    camera.fov = 75;
                    camera.updateProjectionMatrix();
                    break;
                case 'ShiftLeft': case 'ShiftRight':
                    isCrouching = false;
                    currentHeight = PLAYER_HEIGHT;
            }
        }

        function showScoreboard(visible) {
            tabScoreboard.style.display = visible ? 'flex' : 'none';
            if (visible) {
                blueList.innerHTML = '';
                redList.innerHTML = '';
                
                const addPlayer = (id, nick, team) => {
                    const stats = playerStats[id] || { kills: 0, deaths: 0 };
                    const li = document.createElement('li');
                    li.innerHTML = `<span>${nick}</span> <span>${stats.kills} / ${stats.deaths}</span>`;
                    (team === 'blue' ? blueList : redList).appendChild(li);
                };
                
                // Add Self
                if (myPeerId) addPlayer(myPeerId, myNickname, myTeam);
                
                // Add Others
                for (let id in remotePlayers) {
                    addPlayer(id, remotePlayers[id].userData.nick, remotePlayers[id].userData.team);
                }
            }
        }

        function onMouseDown(event) {
            lastActivityTime = performance.now();
            if ((!isMobile && !controls.isLocked) || !matchActive) return;
            
            // Shoot
            // 1. Spawn Bullet
            shootSound.currentTime = 0;
            shootSound.play().catch(() => {});
            
            const dir = new THREE.Vector3();
            camera.getWorldDirection(dir);
            spawnBullet(camera.position.clone().add(dir), dir.clone(), true);
            
            // Visuals
            muzzleLight.intensity = 5;
            setTimeout(() => muzzleLight.intensity = 0, 50);
            camera.rotation.x += 0.02;
            setTimeout(() => camera.rotation.x -= 0.02, 50);

            // Broadcast shot event (for visuals)
            broadcast({ t: 's' });
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function drawMinimap() {
            minimapCtx.clearRect(0, 0, 150, 150);
            
            // Draw Map Border
            minimapCtx.strokeStyle = '#fff';
            minimapCtx.strokeRect(0, 0, 150, 150);

            // Helper to convert world coord to map coord
            const toMap = (val) => ((val + WORLD_SIZE/2) / WORLD_SIZE) * 150;

            // Draw Obstacles
            minimapCtx.fillStyle = '#8b4513';
            obstacles.forEach(obs => {
                const x = toMap(obs.position.x);
                const y = toMap(obs.position.z);
                const s = (1 / WORLD_SIZE) * 150;
                minimapCtx.fillRect(x - s/2, y - s/2, s, s);
            });

            // Draw Remote Players (Red)
            for (let id in remotePlayers) {
                const p = remotePlayers[id];
                if (!p.visible) continue;
                minimapCtx.fillStyle = p.userData.team === 'blue' ? '#009cda' : '#e71e07';
                minimapCtx.beginPath();
                minimapCtx.arc(toMap(p.position.x), toMap(p.position.z), 4, 0, Math.PI*2);
                minimapCtx.fill();
            }

            // Draw Local Player (Blue)
            minimapCtx.fillStyle = myTeam === 'blue' ? '#00ffff' : '#ffaaaa';
            minimapCtx.beginPath();
            minimapCtx.arc(toMap(camera.position.x), toMap(camera.position.z), 4, 0, Math.PI*2);
            minimapCtx.fill();
        }
        
        // Timer Logic (1 second interval)
        setInterval(() => {
            if (gameStarted) {
                if (performance.now() - lastActivityTime > 180000) {
                    exitMatch();
                    statusMsg.innerText = "Kicked for AFK (3 min).";
                    return;
                }
                if (isHost && soloStartTime > 0 && performance.now() - soloStartTime > 300000) {
                    exitMatch();
                    statusMsg.innerText = "Server closed (Empty for 5 min).";
                    return;
                }
            }
            if (matchActive) {
                if (isHost) {
                    matchTime--;
                    broadcast({ t: 'sys', k: 'tick', v: matchTime });
                    if (matchTime <= 0) {
                        broadcast({ t: 'sys', k: 'end' });
                        endGame();
                    }
                }
                
                const m = Math.floor(matchTime / 60);
                const s = matchTime % 60;
                timerEl.innerText = `${m}:${s < 10 ? '0'+s : s}`;
            } else {
                timerEl.innerText = Object.keys(peers).length < 1 ? "WAITING FOR PLAYERS" : "READY";
            }
        }, 1000);

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1); // Cap delta to prevent physics explosion on lag/tab switch

            // Update Bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                b.userData.velocity.y -= (GRAVITY * 0.2) * delta;
                const oldPos = b.position.clone();
                b.position.addScaledVector(b.userData.velocity, delta);

                if (b.position.y <= 0) {
                    createImpact(b.position);
                    scene.remove(b);
                    bullets.splice(i, 1);
                    continue;
                }

                // Projectile Collision Logic
                const dist = b.position.distanceTo(oldPos);
                raycaster.set(oldPos, b.userData.velocity.clone().normalize());
                
                const targets = [...obstacles];
                // Only check against players if it's a local bullet (to deal damage)
                if (b.userData.isLocal) {
                    for (let id in remotePlayers) targets.push(remotePlayers[id].children[0]);
                }
                
                const intersects = raycaster.intersectObjects(targets);
                if (intersects.length > 0 && intersects[0].distance <= dist) {
                    const hitObj = intersects[0].object;
                    createImpact(intersects[0].point);
                    
                    if (b.userData.isLocal && !obstacles.includes(hitObj)) {
                        // Hit a player
                        for (let id in remotePlayers) {
                            if (remotePlayers[id].children[0] === hitObj) {
                                const hitData = { t: 'h', d: 10, targetId: id };
                                if (peers[id]) {
                                    peers[id].send(hitData);
                                } else {
                                    broadcast(hitData);
                                }
                                
                                if (Math.random() < 0.2) {
                                    hitSound.currentTime = 0;
                                    hitSound.play().catch(() => {});
                                }
                                killFeed.innerText = "Hit!";
                                setTimeout(() => killFeed.innerText = '', 500);
                                break;
                            }
                        }
                    }
                    scene.remove(b);
                    bullets.splice(i, 1);
                    continue;
                }

                b.userData.life -= delta;
                if (b.userData.life <= 0) {
                    scene.remove(b);
                    bullets.splice(i, 1);
                }
            }

            // Update Grenades
            for (let i = grenades.length - 1; i >= 0; i--) {
                const g = grenades[i];
                g.userData.velocity.y -= GRAVITY * delta;
                const oldPos = g.position.clone();
                g.position.addScaledVector(g.userData.velocity, delta);
                
                let hit = false;
                // Floor
                if (g.position.y < 0.2) {
                    g.position.y = 0.2;
                    hit = true;
                }
                // Obstacles
                if (!hit) {
                    const dist = g.position.distanceTo(oldPos);
                    raycaster.set(oldPos, g.userData.velocity.clone().normalize());
                    const intersects = raycaster.intersectObjects(obstacles);
                    if (intersects.length > 0 && intersects[0].distance <= dist) {
                        hit = true;
                        g.position.copy(intersects[0].point);
                    }
                }
                if (hit) {
                    explodeGrenade(g.position, g.userData.isLocal);
                    scene.remove(g);
                    grenades.splice(i, 1);
                }
            }

            // Update Particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.life -= delta;
                p.mesh.position.addScaledVector(p.velocity, delta);
                p.mesh.material.opacity = p.life / 0.5;
                if (p.life <= 0) {
                    scene.remove(p.mesh);
                    particles.splice(i, 1);
                }
            }

            // Interpolate Remote Players
            for (let id in remotePlayers) {
                const p = remotePlayers[id];
                if (p.userData.targetPos) {
                    p.position.lerp(p.userData.targetPos, 0.2);
                    p.rotation.y += (p.userData.targetRot - p.rotation.y) * 0.2;
                }
            }

            drawMinimap();

            // Physics & Logic
            
            // Dynamic FOV
            const baseFov = 75;
            const targetFov = (isSprinting && !isCrouching && !isSliding) ? baseFov * 1.15 : baseFov;
            camera.fov += (targetFov - camera.fov) * 0.1;
            camera.updateProjectionMatrix();
            
            // Slide Logic
            if (isSliding) {
                if (performance.now() - lastSlideTime > 800) {
                    isSliding = false;
                    if (isCrouching) {
                        currentHeight = PLAYER_HEIGHT / 2;
                    } else {
                        currentHeight = PLAYER_HEIGHT;
                    }
                }
            }
            
            // Input Processing
            let inputX = 0;
            let inputZ = 0;

            if (isMobile) {
                inputX = joystick.x;
                inputZ = joystick.y;
            } else if (controls.isLocked && !isSliding) {
                inputZ = Number(moveForward) - Number(moveBackward);
                inputX = Number(moveRight) - Number(moveLeft);
            }

            // Run Sound
            const isMoving = Math.abs(inputX) > 0.1 || Math.abs(inputZ) > 0.1;
            if (isMoving && canJump) {
                if (runSound.paused) runSound.play().catch(() => {});
            } else {
                runSound.pause();
            }

            // --- Minecraft Physics Engine ---
            const ticks = delta * 20;
            const onGround = (velocity.y === 0 && canJump);

            // 1. Determine Friction & Acceleration
            let friction = onGround ? FRICTION_GROUND : FRICTION_AIR;
            let accel = ACCEL_AIR;
            
            if (onGround) {
                if (isSliding) { friction = 0.98; accel = 0; } // Sliding on ice-like physics
                else if (isCrouching) accel = ACCEL_SNEAK;
                else if (isSprinting) accel = ACCEL_SPRINT;
                else accel = ACCEL_WALK;
            }

            // 2. Apply Acceleration (Local Space)
            if (inputZ !== 0) velocity.z -= direction.z * accel * ticks;
            if (inputX !== 0) velocity.x -= direction.x * accel * ticks;

            // 3. Apply Friction
            velocity.x *= Math.pow(friction, ticks);
            velocity.z *= Math.pow(friction, ticks);
            
            // Dynamic Hitbox Height
            let boundsHeight = 1.9;
            if (isSliding) boundsHeight = 0.9;
            else if (isCrouching) boundsHeight = 1.4;

            // Ladder Logic
            let onLadder = false;
            const pPos = controls.getObject().position;
            // Calculate center based on feet position (CameraY - currentHeight) + half bounds height
            const pCenter = new THREE.Vector3(pPos.x, pPos.y - currentHeight + (boundsHeight / 2), pPos.z);
            const playerBounds = new THREE.Box3().setFromCenterAndSize(pCenter, new THREE.Vector3(0.5, boundsHeight, 0.5));
            
            for (let l of ladders) {
                if (playerBounds.intersectsBox(l.box)) { onLadder = true; break; }
            }

            if (onLadder) {
                canJump = true;
                maxY = pPos.y;
                
                if (isCrouching) {
                    // Sneak Mechanic: Hold position, no horizontal movement
                    velocity.y = 0;
                    velocity.x = 0;
                    velocity.z = 0;
                } else {
                    // Ascent (Moving Forward)
                    if (moveForward) {
                        velocity.y = 2.35; // ~0.1176 blocks/tick
                    } else {
                        // Descent (Gravity Cap)
                        velocity.y -= GRAVITY * delta;
                        if (velocity.y < -3.0) velocity.y = -3.0; // ~0.15 blocks/tick cap
                    }
                }
            } else {
                velocity.y -= GRAVITY * delta;
            }

            if (velocity.y < 0 && !onLadder) {
                maxY = Math.max(maxY, pPos.y);
            }

            direction.z = inputZ;
            direction.x = inputX;
            direction.normalize();

            // Sliding Collision Logic
            const startPos = controls.getObject().position.clone();
            
            controls.moveRight(-velocity.x * delta);
            controls.moveForward(-velocity.z * delta);

            const endPos = controls.getObject().position.clone();
            const deltaX = endPos.x - startPos.x;
            const deltaZ = endPos.z - startPos.z;
            
            controls.getObject().position.copy(startPos);

            // Apply X
            controls.getObject().position.x += deltaX;
            let playerBox = new THREE.Box3().setFromCenterAndSize(pCenter.set(controls.getObject().position.x, controls.getObject().position.y - currentHeight + (boundsHeight / 2), controls.getObject().position.z), new THREE.Vector3(0.5, boundsHeight, 0.5));
            
            for (let obs of obstacles) {
                const obsBox = new THREE.Box3().setFromObject(obs);
                if (playerBox.intersectsBox(obsBox)) {
                    controls.getObject().position.x -= deltaX;
                    if (isSliding) velocity.x = 0;
                    break;
                }
            }

            // Apply Z
            controls.getObject().position.z += deltaZ;
            playerBox.setFromCenterAndSize(pCenter.set(controls.getObject().position.x, controls.getObject().position.y - currentHeight + (boundsHeight / 2), controls.getObject().position.z), new THREE.Vector3(0.5, boundsHeight, 0.5));
            
            for (let obs of obstacles) {
                const obsBox = new THREE.Box3().setFromObject(obs);
                if (playerBox.intersectsBox(obsBox)) {
                    controls.getObject().position.z -= deltaZ;
                    if (isSliding) velocity.z = 0;
                    break;
                }
            }

            // Map Boundaries
            let pos = controls.getObject().position;
            const limit = WORLD_SIZE / 2;
            if (pos.x < -limit) pos.x = -limit;
            if (pos.x > limit) pos.x = limit;
            if (pos.z < -limit) pos.z = -limit;
            if (pos.z > limit) pos.z = limit;
            
            controls.getObject().position.y += velocity.y * delta;

            // Floor Collision
            if (controls.getObject().position.y < currentHeight) {
                const fallDist = maxY - controls.getObject().position.y;
                if (fallDist > 4) {
                    const dmg = Math.floor((fallDist - 3) * 10);
                    if (dmg > 0) takeDamage(dmg, null);
                }
                maxY = controls.getObject().position.y;
                
                velocity.y = 0;
                controls.getObject().position.y = currentHeight;
                canJump = true;
            }

            // Check Y Collision (Obstacles)
            pos = controls.getObject().position;
            playerBox.setFromCenterAndSize(pCenter.set(pos.x, pos.y - currentHeight + (boundsHeight / 2), pos.z), new THREE.Vector3(0.5, boundsHeight, 0.5));
            
            for (let obs of obstacles) {
                const obsBox = new THREE.Box3().setFromObject(obs);
                if (playerBox.intersectsBox(obsBox)) {
                    if (velocity.y < 0) {
                        const fallDist = maxY - pos.y;
                        if (fallDist > 4) {
                            const dmg = Math.floor((fallDist - 3) * 10);
                            if (dmg > 0) takeDamage(dmg, null);
                        }
                        maxY = pos.y;
                        canJump = true;
                    }
                    controls.getObject().position.y -= velocity.y * delta;
                    velocity.y = 0;
                    break;
                }
            }

            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
