<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Offline Audio Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="apple-touch-icon" href="https://placehold.co/180x180/7e22ce/ffffff?text=Audio&font=inter">
    <style>
        :root {
            --primary-color: #8b5cf6;
            --secondary-color: #1f2937;
            --background-color: #111827;
            --text-color: #f3f4f6;
            --card-color: #1f2937;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            -webkit-tap-highlight-color: transparent;
        }
        .progress-bar-container {
            background-color: #374151;
            height: 6px;
        }
        .progress-bar {
            background-color: var(--primary-color);
            height: 100%;
            transition: width 0.1s linear;
        }
        /* Style for the file input */
        input[type="file"] {
            display: none;
        }
        .custom-file-upload {
            border: 2px dashed #4b5563;
            display: inline-block;
            padding: 1rem 2rem;
            cursor: pointer;
            border-radius: 0.5rem;
            transition: all 0.2s ease-in-out;
        }
        .custom-file-upload:hover, .custom-file-upload.dragover {
            background-color: var(--secondary-color);
            border-color: var(--primary-color);
        }
        /* For iOS safe areas */
        body {
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        .player-controls {
            padding-bottom: calc(1rem + env(safe-area-inset-bottom));
        }
    </style>
</head>
<body class="flex flex-col h-screen antialiased">

    <!-- Header -->
    <header class="bg-gray-900/80 backdrop-blur-sm p-4 text-center sticky top-0 z-10 shadow-lg">
        <h1 class="text-xl font-bold tracking-wider text-purple-400">AudioBox</h1>
        <p class="text-xs text-gray-400">Your Offline Audio Player</p>
    </header>

    <!-- Main Content -->
    <main class="flex-grow overflow-y-auto p-4 md:p-6" id="main-content">
        <!-- Playlist -->
        <div id="playlist-container" class="space-y-3">
            <!-- Audio items will be injected here -->
        </div>

        <!-- Empty State / Upload Prompt -->
        <div id="empty-state" class="hidden text-center text-gray-400 mt-12 p-8">
            <div class="flex justify-center mb-6">
                <svg class="w-20 h-20 text-gray-600" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 6l12-3"></path></svg>
            </div>
            <h2 class="text-2xl font-semibold mb-2 text-gray-300">Your AudioBox is Empty</h2>
            <p class="mb-6">Upload audio files to listen to them anytime, anywhereâ€”even offline.</p>
            <label for="file-upload" class="custom-file-upload text-purple-400">
                <i class="fas fa-plus mr-2"></i>
                <span>Tap to Upload Audio</span>
            </label>
        </div>
        
        <!-- Add to Home Screen Instruction -->
        <div id="install-prompt" class="hidden bg-gray-800 p-4 rounded-lg mt-8 text-center text-sm">
            <p>To install, tap the 'Share' icon in Safari and then 'Add to Home Screen'.</p>
        </div>
    </main>

    <!-- Player Controls -->
    <footer class="player-controls bg-gray-900/80 backdrop-blur-sm p-4 sticky bottom-0 z-10 shadow-[0_-10px_20px_-10px_rgba(0,0,0,0.3)]">
        <div class="max-w-2xl mx-auto">
            <div id="current-track-info" class="text-center mb-3">
                <p id="track-title" class="font-bold truncate">No track selected</p>
                <p id="track-artist" class="text-xs text-gray-400">---</p>
            </div>
            
            <!-- Progress Bar -->
            <div class="mb-3">
                <div id="progress-container" class="progress-bar-container rounded-full cursor-pointer">
                    <div id="progress-bar" class="progress-bar rounded-full"></div>
                </div>
                <div class="flex justify-between text-xs text-gray-400 mt-1">
                    <span id="current-time">0:00</span>
                    <span id="duration">0:00</span>
                </div>
            </div>

            <!-- Player Buttons -->
            <div class="flex items-center justify-center space-x-6">
                <button id="prev-btn" class="text-gray-400 hover:text-white transition-colors disabled:opacity-50 text-2xl"><i class="fas fa-backward-step"></i></button>
                <button id="play-pause-btn" class="bg-purple-600 text-white rounded-full w-16 h-16 flex items-center justify-center text-3xl shadow-lg hover:bg-purple-500 transition-colors disabled:opacity-50"><i class="fas fa-play"></i></button>
                <button id="next-btn" class="text-gray-400 hover:text-white transition-colors disabled:opacity-50 text-2xl"><i class="fas fa-forward-step"></i></button>
            </div>
        </div>
    </footer>

    <!-- Hidden audio element -->
    <audio id="audio-player" class="hidden"></audio>
    <input type="file" id="file-upload" accept="audio/*" multiple>

    <script>
        // --- PWA Setup: Manifest & Service Worker ---
        document.addEventListener('DOMContentLoaded', () => {
            // 1. Dynamically create and inject the manifest
            const manifest = {
                "name": "Offline Audio Player",
                "short_name": "AudioBox",
                "start_url": ".",
                "display": "standalone",
                "background_color": "#111827",
                "theme_color": "#8b5cf6",
                "description": "An offline-first audio player PWA.",
                "icons": [{
                    "src": "https://placehold.co/192x192/7e22ce/ffffff?text=AB&font=inter",
                    "sizes": "192x192",
                    "type": "image/png"
                }, {
                    "src": "https://placehold.co/512x512/7e22ce/ffffff?text=AudioBox&font=inter",
                    "sizes": "512x512",
                    "type": "image/png"
                }]
            };
            const manifestBlob = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
            const manifestURL = URL.createObjectURL(manifestBlob);
            const linkEl = document.createElement('link');
            linkEl.rel = 'manifest';
            linkEl.href = manifestURL;
            document.head.appendChild(linkEl);

            // 2. Register the service worker
            if ('serviceWorker' in navigator) {
                const swContent = `
                    const CACHE_NAME = 'audio-player-cache-v1';
                    const urlsToCache = [
                        '/',
                        'https://cdn.tailwindcss.com',
                        'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css',
                        'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/webfonts/fa-solid-900.woff2'
                    ];
                    self.addEventListener('install', event => {
                        event.waitUntil(
                            caches.open(CACHE_NAME).then(cache => {
                                console.log('Opened cache');
                                return cache.addAll(urlsToCache);
                            })
                        );
                    });
                    self.addEventListener('fetch', event => {
                        event.respondWith(
                            caches.match(event.request).then(response => {
                                return response || fetch(event.request);
                            })
                        );
                    });
                `;
                const swBlob = new Blob([swContent], { type: 'application/javascript' });
                const swURL = URL.createObjectURL(swBlob);
                navigator.serviceWorker.register(swURL)
                    .then(registration => console.log('Service Worker registered with scope:', registration.scope))
                    .catch(error => console.log('Service Worker registration failed:', error));
            }

            // 3. Show install prompt for iOS
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            if (isIOS && !window.navigator.standalone) {
                document.getElementById('install-prompt').classList.remove('hidden');
            }
        });

        // --- Application Logic ---
        const dbName = "AudioPlayerDB";
        let db;

        function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(dbName, 1);
                request.onerror = event => reject("Database error: " + event.target.errorCode);
                request.onsuccess = event => {
                    db = event.target.result;
                    resolve();
                };
                request.onupgradeneeded = event => {
                    const db = event.target.result;
                    db.createObjectStore("tracks", { keyPath: "id", autoIncrement: true });
                };
            });
        }
        
        // DOM Elements
        const fileUpload = document.getElementById('file-upload');
        const customUploadLabel = document.querySelector('.custom-file-upload');
        const mainContent = document.getElementById('main-content');
        const playlistContainer = document.getElementById('playlist-container');
        const emptyState = document.getElementById('empty-state');
        const audioPlayer = document.getElementById('audio-player');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const progressBar = document.getElementById('progress-bar');
        const progressContainer = document.getElementById('progress-container');
        const currentTimeEl = document.getElementById('current-time');
        const durationEl = document.getElementById('duration');
        const trackTitleEl = document.getElementById('track-title');
        const trackArtistEl = document.getElementById('track-artist');

        let playlist = [];
        let currentTrackIndex = -1;

        // --- File Handling & DB ---
        async function handleFiles(files) {
            for (const file of files) {
                if (file.type.startsWith('audio/')) {
                    const track = {
                        name: file.name.replace(/\.[^/.]+$/, ""), // remove extension
                        artist: "Unknown Artist", // You could try to parse metadata later
                        data: file,
                        added: new Date()
                    };
                    await saveTrack(track);
                }
            }
            loadPlaylist();
        }

        function saveTrack(track) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(["tracks"], "readwrite");
                const store = transaction.objectStore("tracks");
                const request = store.add(track);
                request.onsuccess = () => resolve();
                request.onerror = event => reject("Error saving track: " + event.target.error);
            });
        }
        
        async function loadPlaylist() {
            playlist = await getAllTracks();
            renderPlaylist();
            updatePlayerState();
        }

        function getAllTracks() {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(["tracks"], "readonly");
                const store = transaction.objectStore("tracks");
                const request = store.getAll();
                request.onsuccess = event => resolve(event.target.result);
                request.onerror = event => reject("Error loading tracks: " + event.target.error);
            });
        }
        
        function deleteTrack(id) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(["tracks"], "readwrite");
                const store = transaction.objectStore("tracks");
                const request = store.delete(id);
                request.onsuccess = () => {
                    // If the deleted track was the currently playing one
                    if (currentTrackIndex > -1 && playlist[currentTrackIndex].id === id) {
                        audioPlayer.pause();
                        currentTrackIndex = -1;
                        updatePlayerUI();
                    }
                    resolve();
                };
                request.onerror = event => reject("Error deleting track: " + event.target.error);
            });
        }


        // --- UI Rendering ---
        function renderPlaylist() {
            playlistContainer.innerHTML = '';
            if (playlist.length === 0) {
                emptyState.classList.remove('hidden');
                playlistContainer.classList.add('hidden');
            } else {
                emptyState.classList.add('hidden');
                playlistContainer.classList.remove('hidden');
                playlist.forEach((track, index) => {
                    const isPlaying = index === currentTrackIndex;
                    const trackElement = document.createElement('div');
                    trackElement.className = `flex items-center p-3 rounded-lg cursor-pointer transition-colors ${isPlaying ? 'bg-purple-600' : 'bg-gray-800 hover:bg-gray-700'}`;
                    trackElement.dataset.index = index;
                    trackElement.innerHTML = `
                        <div class="mr-4">
                           <i class="fas ${isPlaying && !audioPlayer.paused ? 'fa-pause text-purple-300' : 'fa-play text-purple-400'} text-lg"></i>
                        </div>
                        <div class="flex-grow truncate">
                            <p class="font-semibold">${track.name}</p>
                            <p class="text-sm text-gray-400">${track.artist}</p>
                        </div>
                        <button class="delete-btn text-gray-500 hover:text-red-500 transition-colors p-2" data-id="${track.id}">
                            <i class="fas fa-trash"></i>
                        </button>
                    `;
                    playlistContainer.appendChild(trackElement);
                });
            }
        }
        
        // --- Player Logic ---
        function playTrack(index) {
            if (index < 0 || index >= playlist.length) return;
            
            currentTrackIndex = index;
            const track = playlist[index];
            const objectURL = URL.createObjectURL(track.data);
            audioPlayer.src = objectURL;
            audioPlayer.play();
            
            trackTitleEl.textContent = track.name;
            trackArtistEl.textContent = track.artist;

            updatePlayerState();
            renderPlaylist();
        }

        function togglePlayPause() {
            if (audioPlayer.paused) {
                if (currentTrackIndex === -1 && playlist.length > 0) {
                    playTrack(0);
                } else {
                    audioPlayer.play();
                }
            } else {
                audioPlayer.pause();
            }
        }

        function playNext() {
            let nextIndex = currentTrackIndex + 1;
            if (nextIndex >= playlist.length) {
                nextIndex = 0; // Loop back to the start
            }
            playTrack(nextIndex);
        }

        function playPrev() {
            let prevIndex = currentTrackIndex - 1;
            if (prevIndex < 0) {
                prevIndex = playlist.length - 1; // Loop to the end
            }
            playTrack(prevIndex);
        }
        
        function updatePlayerUI() {
            const isPlaying = !audioPlayer.paused;
            playPauseBtn.innerHTML = `<i class="fas ${isPlaying ? 'fa-pause' : 'fa-play'}"></i>`;
            
            if (currentTrackIndex === -1) {
                trackTitleEl.textContent = "No track selected";
                trackArtistEl.textContent = "---";
            }
            renderPlaylist();
        }

        function updatePlayerState() {
            const hasTracks = playlist.length > 0;
            playPauseBtn.disabled = !hasTracks;
            prevBtn.disabled = !hasTracks;
            nextBtn.disabled = !hasTracks;
        }
        
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
        }

        function updateProgress() {
            if (audioPlayer.duration) {
                const progressPercent = (audioPlayer.currentTime / audioPlayer.duration) * 100;
                progressBar.style.width = `${progressPercent}%`;
                currentTimeEl.textContent = formatTime(audioPlayer.currentTime);
            }
        }
        
        function setProgress(e) {
            const width = this.clientWidth;
            const clickX = e.offsetX;
            const duration = audioPlayer.duration;
            if (duration) {
                audioPlayer.currentTime = (clickX / width) * duration;
            }
        }
        
        // --- Event Listeners ---
        customUploadLabel.addEventListener('click', () => fileUpload.click());
        fileUpload.addEventListener('change', e => handleFiles(e.target.files));

        // Drag & Drop
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            mainContent.addEventListener(eventName, e => {
                e.preventDefault();
                e.stopPropagation();
            }, false);
        });
        ['dragenter', 'dragover'].forEach(eventName => {
            mainContent.addEventListener(eventName, () => {
                customUploadLabel.classList.add('dragover');
            }, false);
        });
        ['dragleave', 'drop'].forEach(eventName => {
            mainContent.addEventListener(eventName, () => {
                customUploadLabel.classList.remove('dragover');
            }, false);
        });
        mainContent.addEventListener('drop', e => {
            handleFiles(e.dataTransfer.files);
        }, false);
        
        playlistContainer.addEventListener('click', async e => {
            const trackElement = e.target.closest('div[data-index]');
            if (e.target.closest('.delete-btn')) {
                e.stopPropagation();
                const button = e.target.closest('.delete-btn');
                const idToDelete = parseInt(button.dataset.id);
                if (!isNaN(idToDelete) && confirm('Are you sure you want to delete this track?')) {
                     await deleteTrack(idToDelete);
                     await loadPlaylist();
                }
            } else if (trackElement) {
                const index = parseInt(trackElement.dataset.index);
                if (index === currentTrackIndex) {
                    togglePlayPause();
                } else {
                    playTrack(index);
                }
            }
        });

        playPauseBtn.addEventListener('click', togglePlayPause);
        nextBtn.addEventListener('click', playNext);
        prevBtn.addEventListener('click', playPrev);
        
        audioPlayer.addEventListener('play', updatePlayerUI);
        audioPlayer.addEventListener('pause', updatePlayerUI);
        audioPlayer.addEventListener('ended', playNext);
        audioPlayer.addEventListener('timeupdate', updateProgress);
        audioPlayer.addEventListener('loadedmetadata', () => {
            durationEl.textContent = formatTime(audioPlayer.duration);
        });

        progressContainer.addEventListener('click', setProgress);

        // --- Initial Load ---
        window.addEventListener('load', async () => {
            try {
                await initDB();
                await loadPlaylist();
            } catch (error) {
                console.error(error);
                alert("Could not initialize the database. The app may not work correctly.");
            }
        });
    </script>

</body>
</html>
